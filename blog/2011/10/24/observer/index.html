<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Design pattern : Observateur | Au coin d'une table</title><meta name=keywords content="java,design pattern"><meta name=description content="Le design pattern de l'évènementiel"><meta name=author content="Isammoc"><link rel=canonical href=https://blog.isammoc.net/blog/2011/10/24/observer/><link href=/assets/css/stylesheet.min.0ef71315edca03ac3fb4b85c2eaba80d9aa9c097f62b53e704ebe8e433907e89.css integrity="sha256-DvcTFe3KA6w/tLhcLquoDZqpwJf2K1PnBOvo5DOQfok=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.isammoc.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.isammoc.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.isammoc.net/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.isammoc.net/apple-touch-icon.png><link rel=mask-icon href=https://blog.isammoc.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="Design pattern : Observateur"><meta property="og:description" content="Le design pattern de l'évènementiel"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.isammoc.net/blog/2011/10/24/observer/"><meta property="article:published_time" content="2011-10-24T00:00:00+00:00"><meta property="article:modified_time" content="2011-10-24T00:00:00+00:00"><meta property="og:site_name" content="Au coin d'une table"><meta name=twitter:card content="summary"><meta name=twitter:title content="Design pattern : Observateur"><meta name=twitter:description content="Le design pattern de l'évènementiel"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://blog.isammoc.net/blog/"},{"@type":"ListItem","position":2,"name":"Design pattern : Observateur","item":"https://blog.isammoc.net/blog/2011/10/24/observer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Design pattern : Observateur","name":"Design pattern : Observateur","description":"Le Design Pattern Observer (Observateur / Observé) est un pattern de comportement. Il permet d’être à l’écoute d’évènements, notemment la modification d’attributs. On appelle …","keywords":["java","design pattern"],"articleBody":"Le Design Pattern Observer (Observateur / Observé) est un pattern de comportement. Il permet d’être à l’écoute d’évènements, notemment la modification d’attributs. On appelle souvent \"écouteur\" les observateurs. Autres noms : Dependents, Publish-Subscribe\n Description du problème On veut depuis une instance connaître le moment où un attribut d’une autre instance est modifié. On veut pouvoir effectuer des actions lorsqu’un évènement survient.\n Exemple de cas d’utilisation :\n   Lorsque l’on a plusieurs vues sur le même modèle. (Une image verte ou rouge selon une valeur qui permet également d’activer ou non un bouton).\n  Lorsque deux valeurs distinctes sont liées. (age avec année de naissance par exemple)\n  Lorsque l’on change un champ dans une feuille de calcul, le diagramme change automatiquement.\n   On verra que cela sera très utile dans le concept Modèle - Vue - Contrôleur.\n   Description de la solution Afin de généraliser, il nous faut savoir quand le sujet est mis à jour. Donc, on va créer une interface avec une méthode \"miseAJour\".\n Toujours pour généraliser (et pas avoir besoin de le faire plusieurs fois), on crée une classe abstraite \"Observable\" avec une méthode qui appelle miseAJour. Comme plusieurs instances peuvent observer, on va gérer une liste du coté de l’Observable, qui connait tous les observateurs.\n Par convention, notifier est public. Puisque le sujet concret peut avoir plusieurs attributs qui changent en même temps, on pourra ne pas appeler notifier durant UNE modification, mais uniquement à la fin de toutes les modifications afin de notifier les observateurs uniquement lorsque le modèle est dans un état stable (après les modifications nécessaires).\n Déroulement usuel   On crée le sujetConcret.\n  On crée l’observateur\n  On abonne l’observateur : sujetConcret.ajouterObservateur(observateur)\n  A un moment donné, quelqu’un change l’état du sujetConcret (setEtat) ce qui appelle (directement ou non) la méthode \"notifier\" qui liste tous les observateurs pour appeler leur méthode \"miseAJour\".\n  Chaque observateurConcret a son propre comportement. Mais la plupart du temps, il va appeler les accesseurs des états le concernant afin de se mettre à jour.\n      Conséquences Couplage faible entre l’observateur et l’observé : On peut changer l’un indépendamment de l’autre dans une certaine mesure. Aucun besoin pour le sujet concret de connaitre tous les types qui vont l’observer. Pas besoin pour mon champ Nombre de connaitre la cellule de ma feuille, mon diagramme en bar, ainsi que mon camembert, ni qu’une autre cellule a besoin de sa valeur pour se calculer ; il suffit à mon type Nombre de prévenir ses observateurs qu’il change. C’est à eux de se débrouiller.\n On peut à tout moment changer l’observateur de sujet, ce qui est possible en le désabonnant d’un sujet et en l’abonnant à un autre. (Réinitialisation d’un modèle, etc.)\n Prévoyance de la modification multiple.\n   Important  On ne doit appeler notifier que si le sujet a réellement été modifié.\n Par exemple : sujetConcret.setEtat(sujetConcret.getEtat()) NE DOIT PAS appeler notifier !!! (risque de boucle de notification sans fin lors de modèle lié)\n       En Java Observable Implémentation de base du pattern. Avec les types :\n   java.util.Observable\n  java.util.Observer\n   Dont l’Observable ne notifie les instances d’Observer uniquement si l’on a appelé setChanged() auparavant.\n  PropertyChange Implémentation du pattern Observer un peu \"amélioré\". On notifie en même temps le nom de l’attribut (la propriété) qui a été modifié, son ancienne et sa nouvelle valeur. (ce qui permet que l’Observateur n’a pas besoin de rappeler le sujet ensuite, voire qu’il n’a même pas besoin de connaitre le sujet réel, uniquement la valeur modifiée).\n   java.beans.PropertyChangeSupport\n  java.beans.PropertyChangeListener\n   La classe de support permet de faire de la délégation. On verra ce principe plus en détail avec le pattern Stratégie.\n  VetoableChange   java.beans.VetoableChangeSupport\n  java.beans.VetoableChangeListener\n   Ajout au PropertyChange de la possibilité que l’observateur refuse le changement.(Pas mal pour garder des données cohérentes).\n    Références   http://fr.wikipedia.org/wiki/Observateur_(patron_de_conception)\n  http://en.wikipedia.org/wiki/Observer_pattern\n  http://www.dofactory.com/Patterns/PatternObserver.aspx\n  http://www.research.ibm.com/designpatterns/example.htm\n  http://perfectjpattern.sourceforge.net/dp-observer.html\n     ","wordCount":"614","inLanguage":"en","datePublished":"2011-10-24T00:00:00Z","dateModified":"2011-10-24T00:00:00Z","author":{"@type":"Person","name":"Isammoc"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.isammoc.net/blog/2011/10/24/observer/"},"publisher":{"@type":"Organization","name":"Au coin d'une table","logo":{"@type":"ImageObject","url":"https://blog.isammoc.net/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.isammoc.net/ accesskey=h title="Au coin d'une table (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Au coin d'une table</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://blog.isammoc.net/categories/ title=categories><span>categories</span></a></li><li><a href=https://blog.isammoc.net/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Design pattern : Observateur</h1><div class=post-description>Le design pattern de l'évènementiel</div><div class=post-meta>October 24, 2011&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Isammoc</div></header><div class=post-content><div class=paragraph><p>Le Design Pattern Observer (Observateur / Observé) est un pattern de comportement. Il permet d’être à l’écoute d’évènements, notemment la modification d’attributs. On appelle souvent "écouteur" les observateurs.
Autres noms : Dependents, Publish-Subscribe</p></div><div class=sect1><h2 id=_description_du_problème>Description du problème<a hidden class=anchor aria-hidden=true href=#_description_du_problème>#</a></h2><div class=sectionbody><div class=paragraph><p>On veut depuis une instance connaître le moment où un attribut d’une autre instance est modifié.
On veut pouvoir effectuer des actions lorsqu’un évènement survient.</p></div><div class=paragraph><p>Exemple de cas d’utilisation :</p></div><div class=ulist><ul><li><p>Lorsque l’on a plusieurs vues sur le même modèle. (Une image verte ou rouge selon une valeur qui permet également d’activer ou non un bouton).</p></li><li><p>Lorsque deux valeurs distinctes sont liées. (age avec année de naissance par exemple)</p></li><li><p>Lorsque l’on change un champ dans une feuille de calcul, le diagramme change automatiquement.</p></li></ul></div><div class=paragraph><p>On verra que cela sera très utile dans le concept Modèle - Vue - Contrôleur.</p></div></div></div><div class=sect1><h2 id=_description_de_la_solution>Description de la solution<a hidden class=anchor aria-hidden=true href=#_description_de_la_solution>#</a></h2><div class=sectionbody><div class=paragraph><p>Afin de généraliser, il nous faut savoir quand le sujet est mis à jour.
Donc, on va créer une interface avec une méthode "miseAJour".</p></div><div class=paragraph><p>Toujours pour généraliser (et pas avoir besoin de le faire plusieurs fois), on crée une classe abstraite "Observable" avec une méthode qui appelle miseAJour.
Comme plusieurs instances peuvent observer, on va gérer une liste du coté de l’Observable, qui connait tous les observateurs.</p></div><div class=paragraph><p>Par convention, notifier est public. Puisque le sujet concret peut avoir plusieurs attributs qui changent en même temps, on pourra ne pas appeler notifier durant UNE modification, mais uniquement à la fin de toutes les modifications afin de notifier les observateurs uniquement lorsque le modèle est dans un état stable (après les modifications nécessaires).</p></div><div class=sect2><h3 id=_déroulement_usuel>Déroulement usuel<a hidden class=anchor aria-hidden=true href=#_déroulement_usuel>#</a></h3><div class=ulist><ul><li><p>On crée le sujetConcret.</p></li><li><p>On crée l’observateur</p></li><li><p>On abonne l’observateur : sujetConcret.ajouterObservateur(observateur)</p></li><li><p>A un moment donné, quelqu’un change l’état du sujetConcret (setEtat) ce qui appelle (directement ou non) la méthode "notifier" qui liste tous les observateurs pour appeler leur méthode "miseAJour".</p></li><li><p>Chaque observateurConcret a son propre comportement. Mais la plupart du temps, il va appeler les accesseurs des états le concernant afin de se mettre à jour.</p></li></ul></div></div></div></div><div class=sect1><h2 id=_conséquences>Conséquences<a hidden class=anchor aria-hidden=true href=#_conséquences>#</a></h2><div class=sectionbody><div class=paragraph><p>Couplage faible entre l’observateur et l’observé : On peut changer l’un indépendamment de l’autre dans une certaine mesure.
Aucun besoin pour le sujet concret de connaitre tous les types qui vont l’observer. Pas besoin pour mon champ Nombre de connaitre la cellule de ma feuille, mon diagramme en bar, ainsi que mon camembert, ni qu’une autre cellule a besoin de sa valeur pour se calculer ; il suffit à mon type Nombre de prévenir ses observateurs qu’il change. C’est à eux de se débrouiller.</p></div><div class=paragraph><p>On peut à tout moment changer l’observateur de sujet, ce qui est possible en le désabonnant d’un sujet et en l’abonnant à un autre.
(Réinitialisation d’un modèle, etc.)</p></div><div class=paragraph><p>Prévoyance de la modification multiple.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><div class=title>Important</div></td><td class=content><div class=paragraph><p>On ne doit appeler <code>notifier</code> que si le sujet a réellement été modifié.</p></div><div class=paragraph><p>Par exemple : <code>sujetConcret.setEtat(sujetConcret.getEtat())</code><br>NE DOIT PAS appeler notifier !!!<br>(risque de boucle de notification sans fin lors de modèle lié)</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=_en_java>En Java<a hidden class=anchor aria-hidden=true href=#_en_java>#</a></h2><div class=sectionbody><div class=sect2><h3 id=_observable>Observable<a hidden class=anchor aria-hidden=true href=#_observable>#</a></h3><div class=paragraph><p>Implémentation de base du pattern. Avec les types :</p></div><div class=ulist><ul><li><p><code>java.util.Observable</code></p></li><li><p><code>java.util.Observer</code></p></li></ul></div><div class=paragraph><p>Dont l’Observable ne notifie les instances d’Observer uniquement si l’on a appelé setChanged() auparavant.</p></div></div><div class=sect2><h3 id=_propertychange>PropertyChange<a hidden class=anchor aria-hidden=true href=#_propertychange>#</a></h3><div class=paragraph><p>Implémentation du pattern Observer un peu "amélioré". On notifie en même temps le nom de l’attribut (la propriété) qui a été modifié, son ancienne et sa nouvelle valeur. (ce qui permet que l’Observateur n’a pas besoin de rappeler le sujet ensuite, voire qu’il n’a même pas besoin de connaitre le sujet réel, uniquement la valeur modifiée).</p></div><div class=ulist><ul><li><p><code>java.beans.PropertyChangeSupport</code></p></li><li><p><code>java.beans.PropertyChangeListener</code></p></li></ul></div><div class=paragraph><p>La classe de support permet de faire de la délégation. On verra ce principe plus en détail avec le pattern Stratégie.</p></div></div><div class=sect2><h3 id=_vetoablechange>VetoableChange<a hidden class=anchor aria-hidden=true href=#_vetoablechange>#</a></h3><div class=ulist><ul><li><p><code>java.beans.VetoableChangeSupport</code></p></li><li><p><code>java.beans.VetoableChangeListener</code></p></li></ul></div><div class=paragraph><p>Ajout au PropertyChange de la possibilité que l’observateur refuse le changement.(Pas mal pour garder des données cohérentes).</p></div></div></div></div><div class=sect1><h2 id=_références>Références<a hidden class=anchor aria-hidden=true href=#_références>#</a></h2><div class=sectionbody><div class=ulist><ul><li><p><a href=http://fr.wikipedia.org/wiki/Observateur_(patron_de_conception class=bare>http://fr.wikipedia.org/wiki/Observateur_(patron_de_conception</a>)</p></li><li><p><a href=http://en.wikipedia.org/wiki/Observer_pattern class=bare>http://en.wikipedia.org/wiki/Observer_pattern</a></p></li><li><p><a href=http://www.dofactory.com/Patterns/PatternObserver.aspx class=bare>http://www.dofactory.com/Patterns/PatternObserver.aspx</a></p></li><li><p><a href=http://www.research.ibm.com/designpatterns/example.htm class=bare>http://www.research.ibm.com/designpatterns/example.htm</a></p></li><li><p><a href=http://perfectjpattern.sourceforge.net/dp-observer.html class=bare>http://perfectjpattern.sourceforge.net/dp-observer.html</a></p></li></ul></div></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.isammoc.net/tags/java/>java</a></li><li><a href=https://blog.isammoc.net/tags/design-pattern/>design pattern</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://blog.isammoc.net/>Au coin d'une table</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.b5c50a006af5240e8b9a820c9517fc939c995c2503cb822fca9c6177c10b9926.js integrity="sha256-tcUKAGr1JA6LmoIMlRf8k5yZXCUDy4Ivypxhd8ELmSY=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>